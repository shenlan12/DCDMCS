\defmodule {OrnsteinUhlenbeckProcessEuler}

This class represents an \emph{Ornstein-Uhlenbeck} process
as in \class{OrnsteinUhlenbeckProcess}, but
the process is generated using the simple Euler scheme
\begin{equation}
   X(t_j) - X(t_{j-1}) = \alpha(b - X(t_{j-1}))(t_j - t_{j-1}) +
      \sigma \sqrt{t_j - t_{j-1}}\, Z_j
                                    \label{eq:ornstein-seqEuler}
\end{equation}
where $Z_j \sim N(0,1)$.
This is a good approximation only for small time intervals $t_j - t_{j-1}$.

\bigskip\hrule\bigskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{code}
\begin{hide}
/*
 * Class:        OrnsteinUhlenbeckProcessEuler
 * Description:  
 * Environment:  Java
 * Software:     SSJ 
 * Copyright (C) 2001  Pierre L'Ecuyer and Universite de Montreal
 * Organization: DIRO, Universite de Montreal
 * @author       
 * @since

 * SSJ is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License (GPL) as published by the
 * Free Software Foundation, either version 3 of the License, or
 * any later version.

 * SSJ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * A copy of the GNU General Public License is available at
   <a href="http://www.gnu.org/licenses">GPL licence site</a>.
 */
\end{hide}
package umontreal.iro.lecuyer.stochprocess;\begin{hide}
import umontreal.iro.lecuyer.rng.*;
import umontreal.iro.lecuyer.probdist.*;
import umontreal.iro.lecuyer.randvar.*;

\end{hide}

public class OrnsteinUhlenbeckProcessEuler extends OrnsteinUhlenbeckProcess\begin{hide} {
\end{hide}
\end{code}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection* {Constructors}
\begin{code}

   public OrnsteinUhlenbeckProcessEuler (double x0, double alpha, double b,
                                         double sigma, RandomStream stream)
   \begin{hide} {
      this (x0, alpha, b, sigma, new NormalGen (stream));
   }\end{hide}
\end{code}
\begin{tabb} Constructor with 
parameters $\alpha =$ \texttt{alpha}, $b$, $\sigma =$ \texttt{sigma} and initial
value $X(t_{0}) =$ \texttt{x0}. The normal variates $Z_j$ will be 
generated by inversion using the stream \texttt{stream}.
\end{tabb}
\begin{code}

   public OrnsteinUhlenbeckProcessEuler (double x0, double alpha, double b,
                                         double sigma, NormalGen gen) \begin{hide} {
      super (x0, alpha, b, sigma, gen);
   }\end{hide}
\end{code}
\begin{tabb} Here, the normal variate generator is specified directly
instead of specifying the stream.
The normal generator \texttt{gen} can use another method than inversion.
\end{tabb}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection* {Methods}
\begin{hide}\begin{code}

   public double nextObservation() {
      double xOld = path[observationIndex];
      double x = xOld + (beta - xOld) * alphadt[observationIndex]
                 + sigmasqrdt[observationIndex] * gen.nextDouble();
      observationIndex++;
      path[observationIndex] = x;
      return x;
   }

   public double nextObservation (double nextTime) {
      double previousTime = t[observationIndex];
      double xOld = path[observationIndex];
      observationIndex++;
      t[observationIndex] = nextTime;
      double dt = nextTime - previousTime;
      double x = xOld + alpha * (beta - xOld) * dt
           + sigma * Math.sqrt (dt) * gen.nextDouble();
      path[observationIndex] = x;
      return x;
   }
\end{code}
\begin{tabb} Generates and returns the next observation at time $t_{j+1} =$
 \texttt{nextTime}. Assumes the previous observation time is $t_{j}$ defined 
earlier (either by this method or by \texttt{setObservationTimes}), 
as well as the value of the previous observation $X(t_j)$. 
\emph{Warning}: This method will reset the observations time $t_{j+1}$
for this process to \texttt{nextTime}. The user must make sure that
the $t_{j+1}$ supplied is $\geq t_{j}$.
\end{tabb}
\begin{code}

   public double nextObservation (double x, double dt) {
      x = x + alpha * (beta - x) * dt
            + sigma * Math.sqrt (dt) * gen.nextDouble();
      return x;
    }
\end{code}
\begin{tabb} Generates and returns an observation of the process 
in \texttt{dt} time units,
assuming that the process has value $x$ at the current time.
Uses the process parameters specified in the constructor.
Note that this method does not affect the sample path of the process 
stored internally (if any).
\end{tabb}
\begin{code}

   public double[] generatePath() {
      double x;
      double xOld = x0;
      for (int j = 0; j < d; j++) {
          x = xOld + (beta - xOld)*alphadt[j] + sigmasqrdt[j]*gen.nextDouble();
          path[j + 1] = x;
          xOld = x;
      }
      observationIndex = d;
      return path;
   }
\end{code}
\begin{tabb} Generates a sample path of the process at all observation times,
 which are provided in array \texttt{t}.
 Note that \texttt{t[0]} should be the observation time of \texttt{x0}, 
 the initial value of the process, and \texttt{t[]} should have at least $d+1$
 elements (see the \texttt{setObservationTimes} method).
\end{tabb}
\begin{code}

   protected void initArrays(int d) {
      double dt;
      for (int j = 0; j < d; j++) {
          dt = t[j+1] - t[j];
          alphadt[j]      = alpha * (dt);
          sigmasqrdt[j]   = sigma * Math.sqrt (dt);
      }
   }
}\end{code}
\end{hide}
